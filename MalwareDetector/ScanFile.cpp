#include "pch.h"
#include "ScanFile.h"
#include "MalwareDetectorDlg.h"


uint32_t __cdecl boyer_moore(uint8_t* string, uint32_t stringlen, uint8_t* pat, uint32_t patlen);



unsigned char char2Hex(unsigned char ch)
{
	if (ch >= 'A' && ch <= 'F')
	{
		return (ch - 'A' + 0x0A);
	}
	else if (ch >= 'a' && ch <= 'f')
	{
		return (ch - 'a' + 0x0A);
	}
	else if (ch >= '0' && ch <= '9')
	{
		return (ch - '0');
	}
	else
	{
		return 0;
	}
}

unsigned char twoChar2Hex(unsigned char ch1, unsigned char ch2)
{
	return ((char2Hex(ch1) << 4) + char2Hex(ch2));
}

unsigned char* converChar2Hex(unsigned char* lpSrc, int& nDstBuffLen)
{
	int i = 0;
	int nlen = 0;
	if (!lpSrc)
	{
		return nullptr;
	}

	auto nLen = strlen((const char*)lpSrc);
	if (nLen & 1)
	{
		nDstBuffLen = (nLen + 1) / 2;
	}
	else
	{
		nDstBuffLen = nLen / 2;
	}
	unsigned char* lpDst = new unsigned char[nDstBuffLen];
	memset(lpDst, 0, nDstBuffLen);


	while (lpSrc[i])
	{
		if (lpSrc[i + 1])
		{
			lpDst[nlen++] = twoChar2Hex(lpSrc[i], lpSrc[i + 1]);
		}
		else
		{
			lpDst[nlen++] = twoChar2Hex(0, lpSrc[i]);
			break;
		}
		i += 2;
	}

	return lpDst;
}

CScanFile::CScanFile(void* pNotify, std::vector<CString>& FilesVec)
	:m_pNotify(pNotify), m_TargetFilesVec(FilesVec)
{
}

CScanFile::~CScanFile()
{
}

BOOL CScanFile::Execute()
{
	CMalwareDetectorDlg* pDlg = reinterpret_cast<CMalwareDetectorDlg*>(m_pNotify);
	for (auto& file : m_TargetFilesVec)
	{
		if (pDlg)
		{
			CProgressInfo* pInfo = new CProgressInfo(file);
			PostMessage(pDlg->m_hWnd, WM_PROGRESS, (WPARAM)pInfo, NULL);
		}
		try
		{
			ScanFile(file);
		}
		catch (...)
		{
			CString strLog;
			strLog.Format(_T("Exception: [%s].\r\n"), file);
			OutputDebugString(strLog);
		}
		if (pDlg)
		{
			pDlg->m_ullScannedCnt++;
			PostMessage(pDlg->m_hWnd, WM_PROGRESS, NULL, NULL);
			CString strLog;
			strLog.Format(_T("has scanned count:[%I64d].\r\n"), pDlg->m_ullScannedCnt.load());
			OutputDebugString(strLog);
		}
	}

	return 0;
}

BOOL CScanFile::Abort()
{
	return 0;
}

void CScanFile::ScanFile(CString& strFile)
{
	HANDLE hFile = INVALID_HANDLE_VALUE;
	HANDLE hMap = NULL;
	do 
	{
		CMalwareDetectorDlg* pDlg = reinterpret_cast<CMalwareDetectorDlg*>(m_pNotify);
		if (NULL == pDlg)
		{
			break;
		}

		hFile = CreateFile(strFile, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (INVALID_HANDLE_VALUE == hFile)
		{
			break;
		}
		LARGE_INTEGER llFileSize;
		GetFileSizeEx(hFile, &llFileSize);
		__int64 qwFileSize = llFileSize.QuadPart;

		if (0 == qwFileSize)
		{
			break;
		}

		hMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
		if (NULL == hMap)
		{
			break;
		}
 		RELEASE_HANDLE(hFile);


		static DWORD dwGran = 0;
		if (0 == dwGran)
		{
			SYSTEM_INFO si;
			GetSystemInfo(&si);
			dwGran = si.dwAllocationGranularity * 1000;
		}
		DWORD dwBlockBytes = dwGran;


		auto nBoundaryDataLen = pDlg->m_nSequeMaxLen - 1;
		std::unique_ptr<uint8_t> lpTailData(new uint8_t[nBoundaryDataLen]);
		std::unique_ptr<uint8_t> lpHeadData(new uint8_t[nBoundaryDataLen]);
		std::unique_ptr<uint8_t> lpAcrossData(new uint8_t[nBoundaryDataLen *2]); // Save data across tow different MapView

		bool bFind = false;
		__int64 qwFileOffset = 0;
		int nTailBytes = 0, nHeadBytes = 0;
		while (qwFileSize > 0 && !bFind)
		{
			bool bCopy = false;
			dwBlockBytes = (qwFileSize < dwBlockBytes) ? qwFileSize : dwBlockBytes;			
			uint8_t* lpAddr = (uint8_t*)MapViewOfFile(hMap, FILE_MAP_ALL_ACCESS, (DWORD)(qwFileOffset>>32), (DWORD)(qwFileOffset&0xFFFFFFFF), dwBlockBytes);
			if (NULL == lpAddr)
			{
				break;
			}

			nHeadBytes = (dwBlockBytes > nBoundaryDataLen) ? nBoundaryDataLen : dwBlockBytes;
			memcpy(lpHeadData.get(), lpAddr, nHeadBytes);

			for (auto it : pDlg->m_SequenceMap)
			{
				int nDstBuffLen = 0;
				std::unique_ptr<unsigned char> lpDst;
				auto lpRet = converChar2Hex((unsigned char*)(it.first.c_str()), nDstBuffLen);
				if (!lpRet)
				{
					continue;
				}
				lpDst.reset(lpRet);
				int nPos = (int)boyer_moore(lpAddr, dwBlockBytes, lpDst.get(), nDstBuffLen);
				// find sequence
				if (nPos >= 0)
				{
					m_FileGuidMap[strFile.GetBuffer()] = it.second;
					bFind = true;
					CFileGuid* pFind = new CFileGuid(it.second, strFile.GetBuffer());
					if (pFind)
					{
						PostMessage(pDlg->m_hWnd, WM_FINDFILE, (WPARAM)pFind, NULL);
					}
					break;
				}
				else
				{
					if ((nTailBytes > 0) && (nHeadBytes > 0) && !bCopy)
					{
						memcpy(lpAcrossData.get(), lpTailData.get(), nTailBytes);
						memcpy(lpAcrossData.get()+nTailBytes, lpHeadData.get(), nHeadBytes);
						bCopy = true;
					}
					if (bCopy)
					{
						nPos = (int)boyer_moore(lpAcrossData.get(), nTailBytes + nHeadBytes, lpDst.get(), nDstBuffLen);
						if (nPos >= 0)
						{
							m_FileGuidMap[strFile.GetBuffer()] = it.second;
							bFind = true;
							CFileGuid* pFind = new CFileGuid(it.second, strFile.GetBuffer());
							if (pFind)
							{
								PostMessage(pDlg->m_hWnd, WM_FINDFILE, (WPARAM)pFind, NULL);
							}
							break;
						}
					}

				}
			}
			if (!bFind)
			{
				auto nTailOffset = (dwBlockBytes > nBoundaryDataLen) ? (dwBlockBytes - nBoundaryDataLen) : dwBlockBytes;
				nTailBytes = (dwBlockBytes > nBoundaryDataLen) ? nBoundaryDataLen : dwBlockBytes;
				memcpy(lpTailData.get(), lpAddr + nTailOffset, nTailBytes);
			}


			UnmapViewOfFile(lpAddr);
			qwFileOffset += dwBlockBytes;
			qwFileSize -= dwBlockBytes;
		}
	} while (false);

	RELEASE_HANDLE(hFile);
	RELEASE_HANDLE(hMap);
	return;
}



CGetAllFiles::CGetAllFiles(void* pWork, std::set<CString>& Dirs)
	:m_pWorker(pWork), m_DirsSet(Dirs)
{
}

CGetAllFiles::~CGetAllFiles()
{
}

BOOL CGetAllFiles::Execute()
{
	for (auto dir : m_DirsSet)
	{
		GetAllFilesInDir(dir);
	}

	if (m_pWorker)
	{
		CMalwareDetectorDlg* pWork = reinterpret_cast<CMalwareDetectorDlg*>(m_pWorker);
		pWork->AddTargetFiles(m_FilesVec);		
	}


	return 0;
}

BOOL CGetAllFiles::Abort()
{
	return 0;
}

void CGetAllFiles::GetAllFilesInDir(CString& strDir)
{
	WIN32_FIND_DATA wfd;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	AppendSplitChar(strDir);
	CString strDirSpec = strDir + _T("*.*");
	hFind = FindFirstFile(strDirSpec, &wfd);
	if (INVALID_HANDLE_VALUE != hFind)
	{
		do
		{
			if (_tcscmp(_T("."), wfd.cFileName) && _tcscmp(_T(".."), wfd.cFileName))
			{
				CString strTempFile = strDir + wfd.cFileName;
				if (!PathIsDirectory(strTempFile))
				{
					m_FilesVec.emplace_back(strTempFile);
				}
				else
				{
					GetAllFilesInDir(strTempFile);
				}
			}
		} while (::FindNextFile(hFind, &wfd));
		::FindClose(hFind);
	}

	return;
}
