// MyThreadPool.cpp: implementation of the CMyThreadPool class.
//
//////////////////////////////////////////////////////////////////////

#include "MyThreadPool.h"
#include <process.h>
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMyThreadPool::CMyThreadPool()
{
    ::InitializeCriticalSection(&m_cs);

    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);
    int nThreadNums = sysInfo.dwNumberOfProcessors * 2 + 2;
    m_nThreadNums = nThreadNums;
    m_pThreads = new HANDLE[nThreadNums];
    
    m_hSemaphore[WORKITEM_EVENT] = ::CreateSemaphore(NULL, 0, LONG_MAX, NULL);
    if (m_hSemaphore[WORKITEM_EVENT] == NULL)
    {
        SetMyLastError("CreateSemaphore Error");
    }

    m_hSemaphore[ABORT_EVENT] = ::CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_hSemaphore[ABORT_EVENT] == NULL)
    {
        SetMyLastError("CreateEvent Error");
    }

    for (int i = 0; i < nThreadNums; i++)
    {
        m_pThreads[i] = (HANDLE)_beginthread(ThreadProc, 0, this); 
    }
}

CMyThreadPool::~CMyThreadPool()
{
    int nRet = ::SetEvent(m_hSemaphore[ABORT_EVENT]);
    if (nRet == 0)
    {
        SetMyLastError("SetEvent Error");
    }
    
    ::WaitForMultipleObjects(m_nThreadNums, m_pThreads, TRUE, -1);
    
    delete[] m_pThreads;
    ::DeleteCriticalSection(&m_cs);
    
    ::CloseHandle(m_hSemaphore[WORKITEM_EVENT]);
    ::CloseHandle(m_hSemaphore[ABORT_EVENT]);
    
    for (int i = 0; i < m_QueueWrokItem.size(); i++)
    {
        IWorkItem *pWorkItem = m_QueueWrokItem.front();
        pWorkItem->Abort();
        delete pWorkItem;
    }
    
    if (m_QueueWrokItem.empty())
    {
        int n = 0;
    }
}

CMyThreadPool::CMyThreadPool(int nThreadNums)
{
    // 成员初始化
    ::InitializeCriticalSection(&m_cs);
    m_pThreads = new HANDLE[nThreadNums];  
    m_nThreadNums = nThreadNums; 

    m_hSemaphore[WORKITEM_EVENT] = ::CreateSemaphore(NULL, 0, LONG_MAX, NULL);
    if (m_hSemaphore[WORKITEM_EVENT] == NULL)
    {
        SetMyLastError("CreateSemaphore Error");
    }

    m_hSemaphore[ABORT_EVENT] = ::CreateEvent(NULL, TRUE, FALSE, NULL);    
    if (m_hSemaphore[ABORT_EVENT] == NULL)
    {
        SetMyLastError("CreateEvent Error");
    }

    for (int i = 0; i < nThreadNums; i++)
    {
        m_pThreads[i] = (HANDLE)_beginthread(ThreadProc, 0, this);
    }
    
}

void CMyThreadPool::SetMyLastError(char* psz)
{
    strcpy_s(m_szErr, _countof(m_szErr), psz);
}

void CMyThreadPool::GetMyLastError(char* psz)
{
    strcpy_s(psz, _countof(m_szErr), m_szErr);
}

void CMyThreadPool::ThreadProc(void *pParam)
{
    CMyThreadPool *pThreadPool = (CMyThreadPool*)pParam;

    while(true)
    {
        int nRet = ::WaitForMultipleObjects(EVENT_NUM, pThreadPool->m_hSemaphore, FALSE, INFINITE);
        if ((nRet - WAIT_OBJECT_0) == ABORT_EVENT)
        {
            break;
        }
        
        IWorkItem *pWorkItem = pThreadPool->RemoveWorkItem();
        if (pWorkItem != NULL)
        {
            pWorkItem->Execute();
            delete pWorkItem;
        }
        else
        {
            int i = 0;
        }
    }
    int n = 0;
}

bool CMyThreadPool::InsertWorkItem(IWorkItem* pWorkItem)
{
    //插入任务
    ::EnterCriticalSection(&m_cs);
    m_QueueWrokItem.push(pWorkItem);
    int nRet = ::ReleaseSemaphore(m_hSemaphore[WORKITEM_EVENT], 1, NULL);
    if (nRet == 0)
    {
        SetMyLastError("ReleaseSemaphore Error");
    }
    ::LeaveCriticalSection(&m_cs);

    return false;
}

IWorkItem* CMyThreadPool::RemoveWorkItem()
{
    IWorkItem *pWorkItem = NULL;

    ::EnterCriticalSection(&m_cs);
    if (m_QueueWrokItem.empty())
    {
        ::LeaveCriticalSection(&m_cs);
        return NULL;
    }
    pWorkItem = m_QueueWrokItem.front();
    m_QueueWrokItem.pop();
    ::LeaveCriticalSection(&m_cs);

    return pWorkItem;
}